#pragma once

#include <JuceHeader.h>
#include "SinglePluginLoader.h"
#include "StardustEditor.h"
#include "BannerButtons.h"
#include <array>
#include <atomic>
#include <vector>

using namespace juce;

class OscilloscopeComponent : public juce::Component, private juce::Timer
{
public:
    OscilloscopeComponent()
    {
        buffer.resize(scopeSize, 0.0f);
        startTimerHz(60); // smoother redraws
    }

    void pushSamples(const float* samples, int numSamples)
    {
        const juce::SpinLock::ScopedLockType sl(lock);
        for (int i = 0; i < numSamples; ++i)
        {
            buffer[(size_t)writePos] = samples[i];
            writePos = (writePos + 1) % scopeSize;
        }
    }

    void paint(juce::Graphics& g) override
    {
        auto area = getLocalBounds().toFloat();
        auto back = juce::Colour::fromRGB(0x0b, 0x10, 0x18);
        auto panel = juce::Colour::fromRGB(0x1a, 0x10, 0x33);
        auto glow = juce::Colour::fromRGB(0xff, 0x2f, 0xd0);
        auto trace = juce::Colour::fromRGB(0x27, 0xe8, 0xff);

        g.setColour(back.withAlpha(0.9f));
        g.fillRoundedRectangle(area, 8.0f);
        g.setColour(glow.withAlpha(0.4f));
        g.drawRoundedRectangle(area, 8.0f, 1.6f);

        std::vector<float> snapshot;
        snapshot.resize(scopeSize);
        {
            const juce::SpinLock::ScopedLockType sl(lock);
            int idx = writePos;
            for (size_t i = 0; i < scopeSize; ++i)
            {
                idx = (idx + 1) % scopeSize;
                snapshot[i] = buffer[(size_t)idx];
            }
        }

        // simple smoothing for fluid visuals
        for (size_t i = 1; i < snapshot.size(); ++i)
            snapshot[i] = 0.6f * snapshot[i] + 0.4f * snapshot[i - 1];

        juce::Path p;
        const float midY = area.getCentreY();
        const float amp = area.getHeight() * 0.45f;
        const float w = area.getWidth();
        const size_t N = snapshot.size();
        if (N == 0)
            return;

        for (size_t i = 0; i < N; ++i)
        {
            const float x = (float)i / (float)(N - 1) * w + area.getX();
            const float y = midY - snapshot[i] * amp;
            if (i == 0) p.startNewSubPath(x, y);
            else p.lineTo(x, y);
        }

        g.setColour(trace.withAlpha(0.95f));
        g.strokePath(p, juce::PathStrokeType(2.4f));
    }

private:
    void timerCallback() override { repaint(); }

    static constexpr size_t scopeSize = 1024;
    std::vector<float> buffer;
    int writePos{ 0 };
    juce::SpinLock lock;
};

// Simple neon-style VU meter component
class VUMeter : public juce::Component
{
public:
    void setTargetLevels (float left, float right)
    {
        const auto toNorm = [] (float v)
        {
            const float db = juce::Decibels::gainToDecibels (v, -80.0f);
            return juce::jlimit (0.0f, 1.0f, (db + 80.0f) / 80.0f);
        };

        targetLevel[0] = toNorm (left);
        targetLevel[1] = toNorm (right);
    }

    void setColours (juce::Colour glow, juce::Colour fill, juce::Colour back) noexcept
    {
        glowColour = glow;
        fillColour = fill;
        backColour = back;
        repaint();
    }

    void tick (float smoothing)
    {
        for (int i = 0; i < 2; ++i)
        {
            const auto delta = targetLevel[i] - currentLevel[i];
            currentLevel[i] += delta * smoothing;
        }
        repaint();
    }

    void paint (juce::Graphics& g) override
    {
        auto area = getLocalBounds().toFloat();
        const auto border = 3.0f;
        auto barArea = area.reduced (border);

        g.setColour (backColour.withAlpha (0.6f));
        g.fillRoundedRectangle (area, 6.0f);

        g.setColour (glowColour.withAlpha (0.5f));
        g.drawRoundedRectangle (area, 6.0f, 1.8f);

        const float gap = 4.0f;
        const float barW = (barArea.getWidth() - gap) / 2.0f;

        for (int i = 0; i < 2; ++i)
        {
            auto single = barArea.withWidth (barW).withX (barArea.getX() + i * (barW + gap));
            auto levelHeight = single.getHeight() * currentLevel[i];
            juce::Rectangle<float> levelRect { single.getX(),
                                               single.getBottom() - levelHeight,
                                               single.getWidth(),
                                               levelHeight };

            juce::ColourGradient grad (fillColour.brighter (0.3f), levelRect.getX(), levelRect.getY(),
                                       fillColour.darker (0.2f), levelRect.getX(), levelRect.getBottom(), false);
            grad.addColour (0.5f, glowColour.withAlpha (0.7f));
            g.setGradientFill (grad);
            g.fillRoundedRectangle (levelRect, 4.0f);
        }

        // dB scale ticks on the left
        g.setColour (juce::Colours::white.withAlpha (0.55f));
        g.setFont (10.0f);
        const int dBMarks[] = { 0, -3, -6, -10, -20, -40, -60 }; // mapped to -80..0 range
        for (int db : dBMarks)
        {
            const float norm = juce::jlimit (0.0f, 1.0f, (db + 80.0f) / 80.0f);
            const float y = barArea.getBottom() - norm * barArea.getHeight();
            const float x1 = area.getX() + 2.0f;
            const float x2 = x1 + 6.0f;
            g.drawLine (x1, y, x2, y, 1.0f);
            g.drawText (juce::String (db), (int) x2 + 2, (int) (y - 6), 24, 12, juce::Justification::centredLeft, false);
        }
    }

private:
    std::array<float, 2> targetLevel { 0.0f, 0.0f };
    std::array<float, 2> currentLevel { 0.0f, 0.0f };
    juce::Colour glowColour { juce::Colour::fromRGB (0xff, 0x2f, 0xd0) };
    juce::Colour fillColour { juce::Colour::fromRGB (0x27, 0xe8, 0xff) };
    juce::Colour backColour { juce::Colour::fromRGB (0x10, 0x0d, 0x18) };
};

//==============================================================================
/*
    This component lives inside our window, and this is where you should put all
    your controls and content.
*/
class MainComponent  : public juce::AudioAppComponent,
                      private juce::Timer
{
public:
    //==============================================================================
    MainComponent();
    ~MainComponent() override;

    //==============================================================================
    void prepareToPlay (int samplesPerBlockExpected, double sampleRate) override;
    void getNextAudioBlock (const juce::AudioSourceChannelInfo& bufferToFill) override;
    void releaseResources() override;

    //==============================================================================
    void paint (juce::Graphics& g) override;
    void resized() override;
    bool loadPluginFile(const juce::File& pluginFile, juce::String& errorMessage);
    bool keyPressed (const juce::KeyPress& key) override;

private:
    void timerCallback() override;
    void toggleFullScreen();

    //==============================================================================
    // Your private member variables go here...

    StardustEditor parameterGrid;
    juce::TextButton loadButton { "Load Stardust" };
    BannerButtons bannerButtons;
    std::unique_ptr<juce::FileChooser> fileChooser;
    juce::Image backgroundImage;
    SinglePluginLoader pluginLoader;
    bool pluginPrepared = false;
    bool bypassEnabled = false;
    double currentSampleRate = 0.0;
    int currentBlockSize = 0;
    bool autoLoadAttempted = false;
    bool showLoadButton = false;
    float gradientPhase = 0.0f;
    std::atomic<float> tonalEnergy { 0.0f };
    float bannerEnergy = 0.0f;
    std::atomic<float> rhythmEnergy { 0.0f };
    float bannerRhythm = 0.0f;
    float prevEnergy = 0.0f;

    std::array<std::atomic<float>, 2> rmsInput { 0.0f, 0.0f };
    std::array<std::atomic<float>, 2> rmsOutput { 0.0f, 0.0f };
    VUMeter meterInput;
    VUMeter meterOutput;
    OscilloscopeComponent oscilloscope;
    void updateButtonVisibility();
    void handleManualLoad();
    void showAudioSettings();
    void setBypass (bool shouldBypass);
     
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent)
};












































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































;










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































